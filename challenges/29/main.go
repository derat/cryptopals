// Copyright 2020 Daniel Erat. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Break a SHA-1 keyed MAC using length extension
package main

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/derat/cryptopals/common"
	"github.com/derat/cryptopals/sha1"
)

var key []byte    // randomly chosen from /usr/share/dict/words
var maxKeyLen int // maximum potential key length

func init() {
	word, ml := common.RandWord()
	key = []byte(word)
	maxKeyLen = ml
}

// sign prepends the secret key to msg and returns a SHA1 hash of the resulting buffer.
func sign(msg []byte) []byte {
	concat := append([]byte{}, key...)
	concat = append(concat, msg...)
	mac := sha1.Sum(concat)
	return mac[:]
}

// verify returns true if mac appears to have been generated by passing msg to sign().
func verify(msg, mac []byte) bool {
	return bytes.Equal(sign(msg), mac)
}

func main() {
	// Per the challenge:
	//   Using this attack, generate a secret-prefix MAC under a secret key (choose a random word from
	//   /usr/share/dict/words or something) of [this string].
	const omsg = "comment1=cooking%20MCs;userdata=foo;comment2=%20like%20a%20pound%20of%20bacon"
	omac := sign([]byte(omsg))
	if !verify([]byte(omsg), omac) {
		panic("failed verifying MAC")
	}

	var state [5]uint32
	if err := binary.Read(bytes.NewReader(omac), binary.BigEndian, state[:]); err != nil {
		panic(fmt.Sprintf("failed reading MAC %x as state: %v", omac, err))
	}

	const extra = ";admin=true"
	admin := false
	for kl := 0; kl <= maxKeyLen; kl++ {
		// First, figure out total message length used to generate the original hash.
		// The amount of padding is dependent on the (unknown) length of the key
		// and the (known) length of the original message.
		olen := kl + len(omsg)
		pad := common.MDPadding(olen)

		// Initialize a new hash.Hash and write the original message length's worth of
		// data to it, including the unknown key and the padding. The content doesn't matter,
		// since we're going to inject the state that resulted after generating the original MAC.
		// This just sets up the hash's other internal variables (e.g. message length).
		h := sha1.New()
		h.Write(common.A(olen + len(pad)))

		// Restore the state that the hash was in when the original MAC was generated (which
		// is just the original MAC itself) and then add our extra data.
		sha1.SetState(h, state)
		h.Write([]byte(extra))
		mac := h.Sum(nil)

		// If this was the correct key length, we should now have a MAC corresponding to the
		// original message, plus the padding, plus our extra data.
		msg := append([]byte(omsg), pad...)
		msg = append(msg, []byte(extra)...)
		if verify(msg, mac[:]) {
			fmt.Printf("Generated valid MAC %x for %q using key length %v\n", mac, msg, kl)
			fmt.Printf("This attack isn't capable of getting the key, but it was %q\n", key)
			admin = true
			break
		}
	}
	if !admin {
		panic("Didn't get MAC")
	}
}
