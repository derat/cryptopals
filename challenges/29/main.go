// Copyright 2020 Daniel Erat. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Break a SHA-1 keyed MAC using length extension
package main

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"fmt"
	"math"
	"math/rand"
	"os"

	"github.com/derat/cryptopals/common"
	"github.com/derat/cryptopals/sha1"
)

var key []byte    // randomly chosen from /usr/share/dict/words
var maxKeyLen int // maximum potential key length

func init() {
	// The rand package just seeds with 1 by default.
	rand.Seed(common.RandInt64(math.MaxInt64))

	// Use a random word as the key.
	f, err := os.Open("/usr/share/dict/words")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	nw := 0
	sc := bufio.NewScanner(f)
	for sc.Scan() {
		nw++
		w := sc.Text()
		if len(w) > maxKeyLen {
			maxKeyLen = len(w)
		}
		if rand.Float64() < 1/float64(nw) {
			key = []byte(w)
		}
	}
	if err := sc.Err(); err != nil {
		panic(err)
	}
}

// sign prepends the secret key to msg and returns a SHA1 hash of the resulting buffer.
func sign(msg []byte) []byte {
	concat := append([]byte{}, key...)
	concat = append(concat, msg...)
	mac := sha1.Sum(concat)
	return mac[:]
}

// verify returns true if mac appears to have been generated by passing msg to sign().
func verify(msg, mac []byte) bool {
	return bytes.Equal(sign(msg), mac)
}

// genPadding computes SHA-1 MD padding for a message of length mlen *bytes*.
//
// Here is how Wikipedia describes the algorithm:
//
//   append the bit '1' to the message e.g. by adding 0x80 if message length is a multiple of 8 bits.
//   append 0 ≤ k < 512 bits '0', such that the resulting message length in bits
//     is congruent to −64 ≡ 448 (mod 512)
//   append ml, the original message length, as a 64-bit big-endian integer.
//   Thus, the total length is a multiple of 512 bits.
func genPadding(mlen int) []byte {
	var b bytes.Buffer
	b.Grow(64)

	// Start with a '1' bit (while filling the rest of the byte with zeros).
	b.Write([]byte{0x80})

	// Pad out the message so the length so far (including the byte we just added) modulo 64 is 56 bytes.
	for (mlen+b.Len())%64 != 56 {
		b.Write([]byte{0x0})
	}

	// Now add the original length in bits.
	binary.Write(&b, binary.BigEndian, uint64(mlen*8))

	return b.Bytes()
}

func main() {
	// Per the challenge:
	//   Using this attack, generate a secret-prefix MAC under a secret key (choose a random word from
	//   /usr/share/dict/words or something) of [this string].
	const omsg = "comment1=cooking%20MCs;userdata=foo;comment2=%20like%20a%20pound%20of%20bacon"
	omac := sign([]byte(omsg))
	if !verify([]byte(omsg), omac) {
		panic("failed verifying MAC")
	}

	var state [5]uint32
	if err := binary.Read(bytes.NewReader(omac), binary.BigEndian, state[:]); err != nil {
		panic(fmt.Sprintf("failed reading MAC %x as state: %v", omac, err))
	}

	const extra = ";admin=true"
	admin := false
	for kl := 0; kl <= maxKeyLen; kl++ {
		// First, figure out total message length used to generate the original hash.
		// The amount of padding is dependent on the (unknown) length of the key
		// and the (known) length of the original message.
		olen := kl + len(omsg)
		pad := genPadding(olen)

		// Initialize a new hash.Hash and write the original message length's worth of
		// data to it, including the unknown key and the padding. The content doesn't matter,
		// since we're going to inject the state that resulted after generating the original MAC.
		// This just sets up the hash's other internal variables (e.g. message length).
		h := sha1.New()
		h.Write(common.A(olen + len(pad)))

		// Restore the state that the hash was in when the original MAC was generated (which
		// is just the original MAC itself) and then add our extra data.
		sha1.SetState(h, state)
		h.Write([]byte(extra))
		mac := h.Sum(nil)

		// If this was the correct key length, we should now have a MAC corresponding to the
		// original message, plus the padding, plus our extra data.
		msg := append([]byte(omsg), pad...)
		msg = append(msg, []byte(extra)...)
		if verify(msg, mac[:]) {
			fmt.Printf("Generated valid MAC %x for %q using key length %v\n", mac, msg, kl)
			fmt.Printf("This attack isn't capable of getting the key, but it was %q\n", key)
			admin = true
			break
		}
	}
	if !admin {
		panic("Didn't get MAC")
	}
}
